#ifndef SIMPLE_SORT_H_INCLUDED
#define SIMPLE_SORT_H_INCLUDED

/*  冒泡排序
遍历数组，将最大的移到最后。逐渐缩小数组范围。

具体步骤：
1. 第一个 for 循环 P=N-1：将最大的数放到最后面
第一趟冒泡，从第一个数开始逐个向后比较，将最大的数向后移动。
2. 第二个 for 循环 P=N-2：将次大的书放到倒数第二个位置上
第二趟冒泡，从第一个数开始逐个向后比较，比较到第二个位置为止

复杂度分析：
最好情况,数组本身是顺序的，那么外循环只需要执行一次就会发现 flag 标识没变 T=O(N),
最差情况，数组本身是倒序的，那么外循环会执行 N-1 次，总的计算量是 (N-1 + N-2 +...+ 1), 则时间复杂度是 T=O(N^2)

*/

void Bubble_sort(int num[], int N)
{
    for ( int P=N-1; P>0; P--)
    {
        int flag = 0;    // 如果flag 没有发生变化，证明前面的已经排序好了，就不需要缩小数组范围，继续比较了。
        for (int i=0; i<P; i++)
        {
            if(num[i] > num[i+1])
            {
                int temp = num[i];
                num[i] = num[i+1];
                num[i+1] = temp;
                flag = 1;
            }
        }
        if (flag == 0) break;
    }
}


/* 插入排序
插入排序是增加增大比较范围。

从数组中先取一个数;
再取第二个数，与前面的进行比较，如果比前面的小，则交换位置。
再取第三个数，与前面的进行比较，直到找到比它大的数，插入。
依次循环。。

最好情况，本身就是个正序，外循环还是会执行完 N-1 次，但是内循环对应的只需要只执行一次，就会发现增加的数位置正确。所以总的复杂度还是 O(N)
最差情况，本身是个倒序的, 外循环会执行 N-1次， 内循环对应次数，所以总的是 O(N^2).
*/

void InsertOrder(int num[], int N)
{
    for(int i=1; i<N; i++)
    {
        for(int j=i; j>0; j--)
        {
            int flag = 0;
            if (num[j] < num[j-1])
            {
                int temp = num[j];
                num[j] = num[j-1];
                num[j-1] = temp;
                flag = 1;
            }

            if(flag == 0) break;   // 这里的 flag 是放在第二个循环里面的，因为找到了位置，就停下来了，后面的排好序的肯定比他大，就不用比较了
        }
    }
}

/*
对比冒泡排序和插入排序

冒泡排序是从数组末尾想头逐渐有序，插入排序是从头到尾逐渐有序。
区别就是flag的位置不同。
*/


#endif // SIMPLE_SORT_H_INCLUDED
